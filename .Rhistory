abline(v=lambda_hat,col="tomato",lwd=3)
## bootrsrap estimate of se and bias
times = c(3, 5, 7, 18, 43, 85, 91, 98, 100, 130, 230, 487)
lambda_hat = 1/mean(times)
# bootstrap estimate of se and bias of the estimator 1/mean(x) for lambda
B <- 200
n <- length(times)
b <- numeric(B)
for(i in 1:B) {
b[i] = 1/mean(sample(times, n, replace = T))
}
se = sd(b)
bias = mean(b) - lambda_hat
cbind(lambda_hat, se, bias)
# visualize distribution of bootstrap replicas
hist(b, las = 1, prob = T)
abline(v=lambda_hat,col="tomato",lwd=3)
## bootrsrap estimate of se and bias
times = c(3, 5, 7, 18, 43, 85, 91, 98, 100, 130, 230, 487)
lambda_hat = 1/mean(times)
# bootstrap estimate of se and bias of the estimator 1/mean(x) for lambda
B <- 200
n <- length(times)
b <- numeric(B)
for(i in 1:B) {
b[i] = 1/mean(sample(times, n, replace = T))
}
se = sd(b)
bias = mean(b) - lambda_hat
cbind(lambda_hat, se, bias)
# visualize distribution of bootstrap replicas
hist(b, las = 1, prob = T)
abline(v=lambda_hat,col="tomato",lwd=3)
data = c(173, 183, 187, 179, 180, 186, 179, 196, 202, 198, 197, 185, 194, 185, 191, 182, 182, 187, 184, 186)
ecdf <- function(x) return(sum(x <= data))
plot(170:210, ecdf)
data = c(173, 183, 187, 179, 180, 186, 179, 196, 202, 198, 197, 185, 194, 185, 191, 182, 182, 187, 184, 186)
ecdf <- function(x) return(sum(x <= data))
range = 170:210
plot(range, ecdf(range))
range = 170:210
ecdf(range)
apply(range, ecdf)
apply(range, FUN = ecdf)
range
sapply(range, FUN = ecdf)
range = min(data)-5:max(data)+5
plot(range, sapply(range, FUN = ecdf))
range
data = c(173, 183, 187, 179, 180, 186, 179, 196, 202, 198, 197, 185, 194, 185, 191, 182, 182, 187, 184, 186)
ecdf <- function(x) return(sum(data <= x))
range = (min(data)-5):(max(data)+5)
plot(range, sapply(range, FUN = ecdf))
plot(range, sapply(range, FUN = ecdf), type = 'l')
data = c(173, 183, 187, 179, 180, 186, 179, 196, 202, 198, 197, 185, 194, 185, 191, 182, 182, 187, 184, 186)
ecdf <- function(x) return(mean(data <= x))
range = (min(data)-5):(max(data)+5)
plot(range, sapply(range, FUN = ecdf), type = 'l', ylab = "")
plot(range, sapply(range, FUN = ecdf), type = 'l', ylab = "F_n")
data = c(173, 183, 187, 179, 180, 186, 179, 196, 202, 198, 197, 185, 194, 185, 191, 182, 182, 187, 184, 186)
ecdf <- function(x) return(mean(data <= x))
x = (min(data)-5):(max(data)+5)
plot(x, sapply(x, FUN = ecdf), type = 'l', ylab = "F_n")
plot(x, sapply(x, FUN = ecdf), type = 'l', ylab = expression("F_n(x)"))
plot(x, sapply(x, FUN = ecdf), type = 'l', ylab = expression(F_n(x)))
plot(x, sapply(x, FUN = ecdf), type = 'l', ylab = expression(F\_n(x)))
plot(x, sapply(x, FUN = ecdf), type = 'l', ylab = 'F_n(x)')
?length
?size
## bootstrap confidence intervals
data = c(173, 183, 187, 179, 180, 186, 179, 196, 202, 198, 197, 185, 194, 185, 191, 182, 182, 187, 184, 186)
ecdf <- function(x) return(mean(data <= x))
x = (min(data)-5):(max(data)+5)
plot(x, sapply(x, FUN = ecdf), type = 'l', ylab = 'F_n(x)')
mean = mean(data)
# bootstrap estimate of se of mean
B = 500
b = numeric(B)
n = length(data)
for(i in i:B) {
b[i] = mean(sample(data, n, replace = T))
}
se = sd(b)
# standard normal bootstrap CI:
c(mean + qnorm(0.975), mean + qnorm(0.975))
## bootstrap confidence intervals
data = c(173, 183, 187, 179, 180, 186, 179, 196, 202, 198, 197, 185, 194, 185, 191, 182, 182, 187, 184, 186)
ecdf <- function(x) return(mean(data <= x))
x = (min(data)-5):(max(data)+5)
plot(x, sapply(x, FUN = ecdf), type = 'l', ylab = 'F_n(x)')
mean = mean(data)
# bootstrap estimate of se of mean
B = 500
b = numeric(B)
n = length(data)
for(i in i:B) {
b[i] = mean(sample(data, n, replace = T))
}
se = sd(b)
# standard normal bootstrap CI:
c(mean + qnorm(0.975), mean + qnorm(0.975))
c(mean - qnorm(0.975), mean + qnorm(0.975))
c(quantile(data, c(0.025,0.975)))
# standard normal bootstrap CI:
c(mean - qnorm(0.975), mean + qnorm(0.975))
# basic bootstrap CI
c(2*mean - qnorm(c(0.975,0.025)))
# bootstrap percentile CI
c(quantile(data, c(0.025,0.975)))
# standard normal bootstrap CI:
c(mean - qnorm(0.975), mean + qnorm(0.975))
# basic bootstrap CI
c(2*mean - quantile(data, c(0.975,0.025)))
# bootstrap percentile CI
c(quantile(data, c(0.025,0.975)))
# standard normal bootstrap CI:
c(mean - qnorm(0.975), mean + qnorm(0.975))
# basic bootstrap CI
c(2*mean - quantile(data, c(0.975,0.025)))
# bootstrap percentile CI
c(quantile(data, c(0.025,0.975)))
# standard normal bootstrap CI:
c(mean - qnorm(0.975)*se, mean + qnorm(0.975)*se)
# basic bootstrap CI
c(2*mean - quantile(data, c(0.975,0.025)))
# bootstrap percentile CI
c(quantile(data, c(0.025,0.975)))
install.packages("bootstrap")
library(bootstrap)
law
data = law
data
?replicate
n = length(data)
n
n = nrows(data)
n = nrow(data)
B = 2000
n
i = sample(1:n, n, replace = T)
data[i,1]
library(bootstrap)
data = law
n = nrow(data)
B = 2000
r = corr(data[,1],data[,2])
r_hat = numeric(B)
for(i in 1:B) {
i = sample(1:n, n, replace = T)
b[i] = corr(data[i,1],data[i,2])
}
## Bootsrap BCa CI
library(bootstrap)
data = law
n = nrow(data)
B = 2000
r = cor(data[,1],data[,2])
r_hat = numeric(B)
for(i in 1:B) {
i = sample(1:n, n, replace = T)
b[i] = cor(data[i,1],data[i,2])
}
## Bootsrap BCa CI
library(bootstrap)
data = law
n = nrow(data)
B = 2000
r = cor(data[,1],data[,2])
r_hat = numeric(B)
for(i in 1:B) {
i = sample(1:n, n, replace = T)
r_hat[i] = cor(data[i,1],data[i,2])
}
r
mean(r_hat)
## Bootsrap BCa CI
library(bootstrap)
data = law
n = nrow(data)
B = 2000
r = cor(data[,1],data[,2])
r_hat = numeric(B)
for(b in 1:B) {
i = sample(1:n, n, replace = T)
r_hat[b] = cor(data[i,1],data[i,2])
}
r
mean(r_hat)
law
hist(r_hat)
library(bootstrap)
data = law
n = nrow(data)
# conduct bootstrap for the correlation of LSAT and GPA in law
B = 2000
r = cor(data[,1],data[,2])
r_hat = numeric(B)
for(b in 1:B) {
i = sample(1:n, n, replace = T)
r_hat[b] = cor(data[i,1],data[i,2])
}
# compute BCa CI for the correlation r
z0 = qnorm(mean(r_hat < r))
j = numeric(n) # jackknife for correlation
for (i in 1:n) {
j[i] = cor(law[-i,1],law[-i,2])
}
a = sum((mean(j)-j)^3)/(6*(sum((mean(j)-j)^2))^(3/2))
alpha=.05 #compute the percentiles to be used instead of .025 and .975
z1=qnorm(alpha/2)
alpha1=pnorm(z0+(z0+z1)/(1-a*(z0+z1)))
z2=qnorm(1-alpha/2)
alpha2=pnorm(z0+(z0+z2)/(1-a*(z0+z2)))
round(quantile(boots,c(alpha1,alpha2)),2) #95% BCa interval
library(bootstrap)
data = law
n = nrow(data)
# conduct bootstrap for the correlation of LSAT and GPA in law
B = 2000
r = cor(data[,1],data[,2])
r_hat = numeric(B)
for(b in 1:B) {
i = sample(1:n, n, replace = T)
r_hat[b] = cor(data[i,1],data[i,2])
}
# compute BCa CI for the correlation r
z0 = qnorm(mean(r_hat < r))
j = numeric(n) # jackknife for correlation
for (i in 1:n) {
j[i] = cor(law[-i,1],law[-i,2])
}
a = sum((mean(j)-j)^3)/(6*(sum((mean(j)-j)^2))^(3/2))
alpha=.05 #compute the percentiles to be used instead of .025 and .975
z1=qnorm(alpha/2)
alpha1=pnorm(z0+(z0+z1)/(1-a*(z0+z1)))
z2=qnorm(1-alpha/2)
alpha2=pnorm(z0+(z0+z2)/(1-a*(z0+z2)))
round(quantile(r_hat,c(alpha1,alpha2)),2) #95% BCa interval
set.seed(1152021) #for reproducibility
library(bootstrap)
data = law
n = nrow(data)
# conduct bootstrap for the correlation of LSAT and GPA in law
B = 2000
r = cor(data[,1],data[,2])
r_hat = numeric(B)
for(b in 1:B) {
i = sample(1:n, n, replace = T)
r_hat[b] = cor(data[i,1],data[i,2])
}
# compute BCa CI for the correlation r
z0 = qnorm(mean(r_hat < r))
j = numeric(n) # jackknife for correlation
for (i in 1:n) {
j[i] = cor(law[-i,1],law[-i,2])
}
a = sum((mean(j)-j)^3)/(6*(sum((mean(j)-j)^2))^(3/2))
alpha=.05 #compute the percentiles to be used instead of .025 and .975
z1=qnorm(alpha/2)
alpha1=pnorm(z0+(z0+z1)/(1-a*(z0+z1)))
z2=qnorm(1-alpha/2)
alpha2=pnorm(z0+(z0+z2)/(1-a*(z0+z2)))
round(quantile(r_hat,c(alpha1,alpha2)),2) #95% BCa interval
z0
a
T
hist(r_hat, prob = T)
hist(j, prob = T)
alpha1
alpha2
library(DAAG)
install.packages("DAAG")
## cross validation for linear model
library(DAAG)
ironslag
data = ironslag[-53]
groups = c(rep(1:26),3)
groups = c(rep(1:26,3),26) # 25 groups with two elements, one with three
length(groups)
groups = c(rep(1:26,2),26) # 25 groups with two elements, one with three
length(groups)
hist(groups)
sort(groups)
ironslag$groups = sample(groups)
ironslag
ironslag[!ironslag$groups == 1]
ironslag$groups
ironslag$groups == 1
ironslag[ironslag$groups == 1,]
library(DAAG)
groups = c(rep(1:26,2),26) # 25 groups with two elements, one with three
ironslag$groups = sample(groups)
errors = numerical(26)
for(i in 1:26) {
data = ironslag[!ironslag$groups == i,]
test = ironslag[ironslag$groups == i,]
model = lm(data$chemical ~ data$magnetic)
error = predict(model, test$magnetic) - test$chemical
errors[i] = sum(error^2)
}
sum(error)
library(DAAG)
groups = c(rep(1:26,2),26) # 25 groups with two elements, one with three
ironslag$groups = sample(groups)
errors = numerical(26)
for(i in 1:26) {
data = ironslag[!ironslag$groups == i,]
test = ironslag[ironslag$groups == i,]
model = lm(data$chemical ~ data$magnetic)
error = predict(model, test$magnetic) - test$chemical
errors[i] = sum(error^2)
}
sum(errors)
errors = numerical(26)
library(DAAG)
groups = c(rep(1:26,2),26) # 25 groups with two elements, one with three
ironslag$groups = sample(groups)
errors = numeric(26)
for(i in 1:26) {
data = ironslag[!ironslag$groups == i,]
test = ironslag[ironslag$groups == i,]
model = lm(data$chemical ~ data$magnetic)
error = predict(model, test$magnetic) - test$chemical
errors[i] = sum(error^2)
}
sum(errors)
## cross validation for linear model
library(DAAG)
groups = c(rep(1:26,2),26) # 25 groups with two elements, one with three
ironslag$groups = sample(groups)
errors = numeric(26)
for(i in 1:26) {
data = ironslag[!ironslag$groups == i,]
test = ironslag[ironslag$groups == i,]
model = lm(data$chemical ~ data$magnetic)
error = predict(model, newdata = test$magnetic) - test$chemical
errors[i] = sum(error^2)
}
sum(errors)
test$magnetic
type(test$magnetic)
typeof(test$magnetic)
## cross validation for linear model
library(DAAG)
groups = c(rep(1:26,2),26) # 25 groups with two elements, one with three
ironslag$groups = sample(groups)
errors = numeric(26)
for(i in 1:26) {
data = ironslag[!ironslag$groups == i,]
test = ironslag[ironslag$groups == i,]
model = lm(data$chemical ~ data$magnetic)
error = predict(model, newdata = test) - test$chemical
errors[i] = sum(error^2)
}
sum(errors)
library(DAAG)
groups = c(rep(1:26,2),26) # 25 groups with two elements, one with three
ironslag$groups = sample(groups)
errors = numeric(26)
for(i in 1:26) {
data = ironslag[!ironslag$groups == i,]
test = ironslag[ironslag$groups == i,]
model = lm(magnetic ~ chemical, data)
error = predict(model, newdata = test) - test$chemical
errors[i] = sum(error^2)
}
sum(errors)
library(DAAG)
groups = c(rep(1:26,2),26) # 25 groups with two elements, one with three
ironslag$groups = sample(groups)
errors = numeric(26)
for(i in 1:26) {
data = ironslag[!ironslag$groups == i,]
test = ironslag[ironslag$groups == i,]
model = lm(magnetic ~ chemical, data)
error = predict(model, newdata = test) - test$magnetic
errors[i] = sum(error^2)
}
sum(errors)
library(DAAG)
groups = c(rep(1:26,2),26) # 25 groups with two elements, one with three
ironslag$groups = sample(groups)
errors = numeric(26)
for(i in 1:26) {
data = ironslag[!ironslag$groups == i,]
test = ironslag[ironslag$groups == i,]
model = lm(magnetic ~ chemical, data = data)
error = predict(model, newdata = test) - test$magnetic
errors[i] = sum(error^2)
}
sum(errors)
library(DAAG)
groups = c(rep(1:26,2),26) # 25 groups with two elements, one with three
ironslag$groups = sample(groups)
errors = numeric(26)
for(i in 1:26) {
data = ironslag[!ironslag$groups == i,]
test = ironslag[ironslag$groups == i,]
model = lm(magnetic ~ chemical, data = data)
error = predict(model, newdata = test) - test$magnetic
errors[i] = sum(error^2)
}
mean(errors)
library(DAAG)
groups = c(rep(1:26,2),26) # 25 groups with two elements, one with three
ironslag$groups = sample(groups)
errors = numeric(26)
for(i in 1:26) {
data = ironslag[!ironslag$groups == i,]
test = ironslag[ironslag$groups == i,]
model = lm(magnetic ~ chemical, data = data)
error = predict(model, newdata = test) - test$magnetic
errors[i] = sum(error^2)
}
sum(errors)/53
library(DAAG)
groups = c(rep(1:26,2),26) # 25 groups with two elements, one with three
ironslag$groups = sample(groups)
errors = numeric(26)
for(i in 1:26) {
data = ironslag[!ironslag$groups == i,]
test = ironslag[ironslag$groups == i,]
model = lm(magnetic ~ chemical, data = data)
error = predict(model, newdata = test) - test$magnetic
errors[i] = sum(error^2)
}
sum(errors)/53
library(DAAG)
groups = c(rep(1:26,2),26) # 25 groups with two elements, one with three
ironslag$groups = sample(groups)
errors = numeric(26)
for(i in 1:26) {
data = ironslag[!ironslag$groups == i,]
test = ironslag[ironslag$groups == i,]
model = lm(magnetic ~ chemical, data = data)
error = predict(model, newdata = test) - test$magnetic
errors[i] = sum(error^2)
}
sum(errors)/53
library(DAAG)
groups = c(rep(1:26,2),26) # 25 groups with two elements, one with three
ironslag$groups = sample(groups)
errors = numeric(26)
for(i in 1:26) {
data = ironslag[!ironslag$groups == i,]
test = ironslag[ironslag$groups == i,]
model = lm(magnetic ~ chemical, data = data)
error = predict(model, newdata = test) - test$magnetic
errors[i] = sum(error^2)
}
sum(errors)/53
library(DAAG)
groups = c(rep(1:26,2),26) # 25 groups with two elements, one with three
ironslag$groups = sample(groups)
errors = numeric(26)
for(i in 1:26) {
data = ironslag[!ironslag$groups == i,]
test = ironslag[ironslag$groups == i,]
model = lm(magnetic ~ chemical, data = data)
error = predict(model, newdata = test) - test$magnetic
errors[i] = sum(error^2)
}
sum(errors)/53
library(DAAG)
groups = c(rep(1:26,2),26) # 25 groups with two elements, one with three
ironslag$groups = sample(groups)
errors = numeric(26)
for(i in 1:26) {
data = ironslag[!ironslag$groups == i,]
test = ironslag[ironslag$groups == i,]
model = lm(magnetic ~ chemical, data = data)
error = predict(model, newdata = test) - test$magnetic
errors[i] = sum(error^2)
}
sum(errors)/53
library(DAAG)
groups = c(rep(1:26,2),26) # 25 groups with two elements, one with three
ironslag$groups = sample(groups)
errors = numeric(26)
for(i in 1:26) {
data = ironslag[!ironslag$groups == i,]
test = ironslag[ironslag$groups == i,]
model = lm(magnetic ~ chemical, data = data)
error = predict(model, newdata = test) - test$magnetic
errors[i] = sum(error^2)
}
sum(errors)/53
library(DAAG)
groups = c(rep(1:26,2),26) # 25 groups with two elements, one with three
ironslag$groups = sample(groups)
errors = numeric(26)
for(i in 1:26) {
data = ironslag[!ironslag$groups == i,]
test = ironslag[ironslag$groups == i,]
model = lm(magnetic ~ chemical, data = data)
error = predict(model, newdata = test) - test$magnetic
errors[i] = sum(error^2)
}
sum(errors)/53
set.seed(487)
library(DAAG)
groups = c(rep(1:26,2),26) # 25 groups with two elements, one with three
ironslag$groups = sample(groups)
errors = numeric(26)
for(i in 1:26) {
data = ironslag[!ironslag$groups == i,]
test = ironslag[ironslag$groups == i,]
model = lm(magnetic ~ chemical, data = data)
error = predict(model, newdata = test) - test$magnetic
errors[i] = sum(error^2)
}
sum(errors)/53
